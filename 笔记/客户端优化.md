# 客户端优化

用户发起请求时，可以利用1亿用户手中的设备帮助我们的系统做事情，用户的设备是用户自己花钱买的，访问你的系统，如果能在手机端就把业务逻辑完成，就能减少系统的访问量，这就是客户端优化需要做的事情



启动APP时，APP可以去后端拉取一些计算规则类的数据缓存到客户端

以后当APP要做某一些请求时，或者业务逻辑时，在APP端计算完成



## 资源压缩



浏览器跟服务端交互、APP跟服务器交互总的来说对客户端都是调用接口而已，通过接口和后端进行交互

不同的操作系统优化的方式都是一样的，浏览器可以理解为另外一种操作系统

资源的获取，资源的处理，资源的展示

资源：样式文本，脚本文件，图片，视频，文本等等

浏览器：DOM树

过程：

**1.资源下载**

快：压缩，减小资源体积，减少在网络上传输的数据量，缩短资源下载的时间

数据量分为两部分：客户端请求给服务端，服务端响应给客户端

**减少不必要的资源传输**

不要将不必要的cookie进行传输，也不要将cookie作为缓存，因为cookie的信息会随着请求发送而发送，增加请求的数据量

举例：

用户登录系统之后就是合法用户，可能cookie会存储一些数据来校验用户是否是合法用户，但是当合法用户去访问一些不需要登录的资源时，这个时候就不需要cookie



压缩的场景：

当用户浏览信息，默认显示的缩略图，当用户鼠标放在缩略图上时，显示的才是原图

这样页面可以减少传输的数据量

![image-20230301202934505](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230301202934505.png)





**JavaScript**：删除无效字符（注释，空格，换行）

（1）减少体积

（2）代码安全，别人看不懂

（3）语义合并

**CSS**：语义合并

举例：

原来10个按钮10个样式，现在class只需要1个样式，节省9行代码



**Http请求压缩**：

客户端给服务端发送http请求，可以对回应的内容进行压缩

客户端给服务端发送请求，在请求头Header中添加参数Accept-Encoding: gzip, deflate

![image-20230302154840934](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230302154840934.png)

该参数表示：客户端可以接受的压缩内容的格式，服务端接收到该请求之后，如果服务端支持相关的压缩格式，服务端将内容按照格式压缩，服务端响应的时候在响应头中Header中添加Content-Encoding: gzip

所以在服务端中尽可能多的给响应的数据手动的进行压缩动作，能够减少网络中数据量的传输



服务端支不支持压缩格式，是程序员写的，是程序员说的算的

![image-20230301204321061](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230301204321061.png)

gzip对文本的压缩在40%以下



**减少请求**：

前端请求后端，建立Http连接，创建连接交换数据，销毁连接，中间包括：请求的发送，三次握手，四次挥手，这个过程都会消耗时间和通信资源

如果系统打开页面，需要下载的资源数目比较多，体积小，频繁创建http连接，对性能带来很大的伤害

减少请求的方案：

1.雪碧图

举例：

只请求一次，本次请求结束后，响应包含多个体积小而数目多的图片

返回的资源如何使用：在样式文件中，通过background-position中移动到需要使用的地方去，通过样式去控制

2.JavaScript合并

将多个JS文件打包成一个文件，便于一次下载完成

3.矢量图

svg标签

![image-20230301210845458](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230301210845458.png)



总结：减少前端和后端的交互

4.base64编码的图片

减少图片的体积

gzip对文本文件的压缩，能够压缩到原来文件大小的40%以下

**总结**：减少图片的体积，可以先将原图进行压缩到缩略图，缩略图再使用base64进行编码，base64再使用gzip进行压缩

5.将图片、静态文件直接请求阿里云，转移给第三方

将流量的压力转移到第三方





## http连接

http：是基于请求和响应模式的，只要服务器给了响应，本次http连接就结束了

http 1.0 不支持长连接

http 1.1 默认是长连接

**长短连接是针对TCP协议的，http没有长短连接这一说**

**TCP是双向通道，可以保持一段时间的不关闭，因此TCP才有长短连接**

http1.1发请求的时候，在请求头中添加参数：connection:keep - alive，底层复用的是TCP的连接，在长连接的情况下，多个http请求可以复用一个TCP连接，节省很多TCP连接的建立和断开的消耗

**优点**：减少了创建和销毁连接资源的消耗

**举例**：

请求的网页：（CSS，JS，HTML），如果每次请求后端都是短连接，都是TCP的连接，打开网页，这么多的资源都要创建和销毁，消耗的资源特别多

如果请求的都是baidu.com的，底层就可以复用TCP和baidu.com打通的连接，节省大量资源的创建和销毁的消耗



**问题**：并发时服务器的连接够用吗？

长连接并不是永久连接，在维持一定的时间内，如果这个连接没有http请求发出的话，连接就会被断掉

维持时间可以在Header中进行设置



**http1.1在项目中的应用**

http1.1在使用的时候，默认长连接，服务端响应的结果在Header中一定要带上参数：connection:keep-alive

如果服务端不带这个参数或者带的参数是：connection:close，那么连接就会关闭

![image-20230302154750935](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230302154750935.png)

**测试**：

```java
@RestController
public class ConnectionController {
	@GetMapping("/test-long-connection")
	public String longConnection(HttpServletResponse response) {
		response.setHeader("connection", "keep-alive");
		return "长连接";
	}
	@GetMapping("/test-short-connection")
	public String shortConnection(HttpServletResponse response) {
		response.setHeader("connection", "close");
		return "短连接";
	}
}
```



长连接

![image-20230302112802138](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230302112802138.png)

短连接

![image-20230302112914709](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230302112914709.png)

通过F5刷新，ID就会变

![image-20230302112927180](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230302112927180.png)

![image-20230302112938075](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230302112938075.png)









### 短轮询

项目中节省资源提高性能的话，会使用长轮询和短轮询

举例：

淘宝中商品的库存需要实时变化的，页面上的库存如何跟实际的库存保持一致

解决方案：

1.脚本，使用JavaScript写一个死循环，不停的请求服务器的库存量是多少，刷新这个页面上的商品库存，也就是短轮询

缺点：浪费服务器和客户端的资源

### 长轮询

长轮询的方式是通过服务端处理方式决定的，与客户端没有关系

客户端超时之后，有两种处理方式：

-   就当服务器没有响应结果，重发请求
-   超时



长轮询和短轮询的区别：

短轮询：去服务端查询的时候，不管库存有没有变化，服务器立即返回结果

长轮询：服务器检测到库存没有变化的话，那么将当前请求挂起一段时间，在这一段时间内，如果检测到库存发生变化，那么立即返回结果，否则一直等到超时为止



### 长轮询的优点

减少客户端的请求量

**举例**：

如果有一部分用户的请求被阻塞住了，节省网络带宽，以及节省到服务器处理请求的资源消耗，解决了服务端一直忙于接收请求的窘境



**测试**：

```java
/**
 * 测试长轮询
 *
 * @author xcy
 * @date 2023/3/2 - 14:18
 */
@RestController
@EnableAsync
public class PollingController {
	@Autowired
	private AsyncRequestService asyncRequestService;
	@GetMapping("/value")
	public String longPolling() {
		String msg = null;
		Future<String> result = null;
		try {
			result = asyncRequestService.getValue();
			msg = result.get(10, TimeUnit.SECONDS);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (result != null) {
				result.cancel(true);
			}
		}
		return msg;
	}
	@PostMapping("/value")
	public void postValue(String msg) {
		asyncRequestService.postValue(msg);
	}
}
```



```java
/**
 * @author xcy
 * @date 2023/3/2 - 14:21
 */
@Service
public class AsyncRequestService {
	private String msg = null;
	@Async
	public Future<String> getValue() throws InterruptedException {
		//检查数据变化的代码
		while (true) {
			synchronized (this) {
				if (msg != null) {
					String resultMsg = msg;
					msg = null;
					return new AsyncResult<>(resultMsg);
				}
			}
			Thread.sleep(100);
		}
	}
	public synchronized void postValue(String msg) {
		this.msg = msg;
	}
}
```





**问题**：如果是查询数据库，那是不是会一直不停的查询下去？

减少查询数据库的查询

1.Redis

2.发布订阅



### 双工通信

实现方式：

-   netty
-   websocket（ws协议）

前后端可以彼此进行交互



## 资源缓存

减少资源下载的次数，节省服务器的资源

### 页面缓存、节点间缓存

可以控制客户端、各级代理（客户端请求服务端时，中间经过的各种节点叫做各级代理）、对页面资源的缓存

如何进行控制：在Headers中的参数：Cache-Control:public

可缓存性：

-   public：可以被中间各级代理进行缓存，由服务器响应进行设置
-   private：只能被客户端缓存，中间各级不缓存，由服务器响应进行设置
-   no-cache（请求，响应）：可以缓存，但是不能直接使用缓存，需要服务端进行验证
-   no-store（请求，响应）：都不能缓存

缓存有效期（一般系统不大时，只配置前两个）：

-   max-age = xx秒，表示缓存可以存活的时间
-   s-maxage = xx秒，表示缓存在各个节点存活的时间，如果是客户端则忽略
-   max-stale = xx秒，表示客户端愿意接受一个已经过期资源，可以设置时长。即：客户端表示资源可以过期，但是过期不可以超过该设置的时长。通俗说：客户端可以忍受资源过期的时间
-   min-fresh = xx秒，表示客户端希望能在指定的时间内，保持其最新状态的响应。

重新验证和加载的设置：

-   must-revalidate：资源过期后，在服务器重新验证之前，不可以使用该资源
-   proxy-revalidate：只对各级节点有效
-   no-transform：不能对该资源进行转换，不能压缩图像
-   only-if-cached：客户端只请求已经缓存的资源而不是向服务器请求新的资源。只要缓存的，不要服务器的

**测试**：

```java
/**
 * 测试页面缓存
 *
 * @author xcy
 * @date 2023/3/2 - 15:28
 */
@RestController
public class PageCacheController {
	@GetMapping("/test-nocache")
	public String testNoCache(HttpServletResponse response) {
		response.setHeader("Cache-Control", "no-cache");
		return "测试页面没有缓存";
	}
	@GetMapping("/test-cache")
	public String testCache(HttpServletResponse response) {
		response.setHeader("Cache-Control", "public,max-age=315360000");
		return "测试页面有缓存";
	}
}
```



结果可以看出缓存的优点：

1.不需要建立连接

2.请求响应相比较于没有缓存的速度极快

3.节省资源的消耗

![image-20230302154053834](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230302154053834.png)



#### 页面缓存更新不及时的解决方案：

##### 1.更新文件名：版本号，url时间戳的变化。

举例：my-js.js 更新为 my-js-1.js，客户端和服务端需要达成一致

index.html文件名不能修改

打包Vue的js和css之后，文件名会发生变化，是可以变化的，那么客户端就可以加载新的文件，旧的文件都会失效，这样就可以避免缓存的更新不及时

html、css和js文件这些文件是可以关联的，当网页缓存重新被部署之后，如果有新的访问，是不能请求到老的缓存的，需要请求新的页面

**本质：发布上线一个文件，这个文件名是变的，那么缓存的文件就失效了**

##### 2.验证缓存的有效性

**基于文件的最后修改时间**：no-cache：服务端验证

服务端响应时带的参数：last-modified:最后修改时间

客户端请求时带的参数：if-modified-since:自己需要资源的时间

**举例**：

服务端接收到客户端发送的请求之后，如果与当前资源的最后修改时间一致，则返回304的状态码，不返回资源；如果不一致，则返回200的状态码，并且返回具体资源

你要我一个手机，我给你一个手机，手机上贴着标签（时间戳），你下次又来要我一个手机，你要手机标签上时间戳之前的手机，假设手机标签上是9：30，你要的是9:45之前，那么肯定满足，返回304状态码，不返回具体的资源；假设手机标签上是9：50，你要的是9:45之前，那么肯定不满足，返回200状态码，返回具体的资源

**基于版本号**

etag：版本号

客户端请求中：if-none-match: 版本号





客户端本地缓存

![image-20230302144858126](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230302144858126.png)





**2.资源解析：元素、样式、脚本**

## 资源解析

目的：从服务端获取到资源之后，按照一定的规则呈现给用户，呈现的过程中可以进行优化解析



### 1.优化正常解析流程

我知道你是怎么呈现的，那么将呈现的环节一个一个优化掉

资源下载：

元素

css样式文件

js脚本文件

这三个链接在一起，通过render tree呈现出来，布局好，最后进行绘制

网页默认的呈现方式是流式布局，从上往下加载，任何前面的元素的大小位置发生变化都会对后面的元素产生影响

这种重新计算全局元素的位置的过程叫做：回流，对性能消耗非常大

重绘：对前端性能消耗非常大

当我们在页面中改变元素的大小位置边距布局以及定位方式的时候，或者使用脚本文件增删DOM操作的时候，都会引发回流和重绘



目的：提前规划好，尽可能的不去变。缩小回流和重绘的范围

解决方案：分几个块

如果元素的大小位置边距布局以及定位方式频繁发生变化，先将元素隐藏起来，等到彻底不变化的时候，再呈现出来

### 2.创新解析流程

我知道你是怎么呈现的，不去修改你的呈现，通过另外的一种呈现的方式对你进行包装

虚拟DOM（Virtual DOM）：当DOM发生变化时，将DOM修改为最新的状态，而不是将DOM删除后重建

算法：比较前后两个DOM的区别，比较之后将该变得地方变了，修改为最终的DOM，这是很多前端框架的思路



**如果改变不了它本来的面目，就给它化化妆，改变呈现的面目**



**Oracle的物化视图**：SQL改不了，但是还需要经常查询，在前面架一层物化视图，将查询结果放到物化视图中，查询物化视图会更快，因为可能查询SQL需要关联多张表，而物化视图仅仅只需要查询一次

**Redis缓存**：查询数据库效率可能很慢，架一层，将数据库的数据前置到缓存中，用户只和缓存打交道也能提升性能





## 懒加载

在页面首次加载，仅仅加载最基础的元素，以后再根据用户的操作，进行局部加载

将原来一次性要加载的内容拆分成多次加载，采用的是分流的思想

回流和重绘的消耗也会减少



懒加载的应用：

网页往下拉动，app往上滑动，树形组件，折叠面板，标签页

尽量灵活一些，多做考虑，支持多种情况



如果前端都不想多调用接口时，或者前端都只想做本地存储时，我们可以按照公司或者整体项目的角度对待问题，给前端人员进行描述



到了不得不看具体数据的时候，才调用后端

但是如果是经常不变的数据，就没有必要了



## 预加载

大部分前端的页面在逻辑上都是连续的，用户在访问某个页面的时候，大概率是通过另外一个页面跳转而来的，先访问一个页面，再点击链接，再跳转某个页面，是有**先后顺序**的

访问网页上的广告通过百度联盟，还有网站点击的连接跳转到该网站域名之外的链接，另外一个网站的加载时间非常长

这个时候就使用到了预加载



懒加载和预加载并不冲突，只不过是使用场景不同

**预加载优化的两种情况：**

1.同一个域名下的

拉取资源

<!-- 针对当前页面的资源，如果当前页面指定资源比较大，更早的加载资源，提升页面加载速度 -->

```html
<link rel="preload" href="xxx.jpg"/>
```



<!-- 针对下一页页面的资源，如果下一个页面存在比较大的资源，浏览器处理完当前页面而闲置的时候，加载该资源，进入下一个页面时，该资源就不需要加载了 -->

```html
<link rel="prefetch" href="xxx.js"/>
```

2.不同域名下的

域名：A，B，C

减少DNS的请求次数，也就是减少域名解析次数

通过DNS缓存



### DNS预获取：

DNS（**D**omain **N**ame **S**ystem）：域名系统，域名与IP地址互相映射的分布式数据库

DNS解析速度，被很多人忽略。浏览器针对DNS进行优化，1次DNS解析大概花费时间：20 ~ 120ms



### DNS预解析：

可能涉及多级递归查询：根服务器，顶级域名服务器，权威域名服务器...，多级之间进行跳转，这个跳转也是非常消耗时间的



预加载（DNS prefetching）：在当前页面，完成对下一个页面域名的解析，而在下一个页面时，直接使用预解析之后的结果

<!-- 通知浏览器，打开域名解析 -->

```html
<meta http-equiv="x-dns-prefetch-control" content="on"/>
```

<!-- 解析指定域名 -->

```html
<link rel="dns-prefetch" href="//www.baidu.com"/>
```

<!-- 通知浏览器，关闭域名解析 -->

```html
<meta http-equiv="x-dns-prefetch-control" content="off"/>
```

扩展：

图片 -> base64 -> 放到css文件中

总结：

预操作不仅可以针对资源下载展开，也可以针对页面解析展开，当存在一个复杂显示界面的时候，可以在页面中以不可预见的形式，提前做了，通过预操作，可以统筹协调资源下载和页面解析的时机，分散网络和请求计算的压力



## 客户端数据库



1个用户1K，1000W用户就是10G

cookie：过期时间

缺点：浏览器会将cookie的信息发送给后端，对于缓存来说是没有必要的，缓存是为了让人去取得，没有必要发送到后端，所以cookie不适合做缓存



![image-20230303082128733](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230303082128733.png)



Local Storage：长久的保存

Session Storage：数据会话结束会销毁

Web SQL：关系型数据库

Cache Storage：以请求为键，以响应为值，避免同样的请求多次调用

Application Cache：缓存页面的内容，实现页面的离线访问，大大减少服务器的压力

这些都需要H5支持和浏览器的支持



sqllite



## 动静分离

动静数据：页面的输出，是否和用户的个性化的要求相关

动态数据：需要从数据库中获取或者不同的用户访问相同的页面看到的不一样

静态数据：相对不会变化的数据

动静分离的优化场景：

媒体类网站：有一篇新闻，需要从数据库中查询获取，但是不同的用户看到的都是一样的

可以将数据库中查询的数据进行前置，作为静态数据



数据不仅包括传统意义上的页面，也包括没有和访问者相关的个性化数据

所以动静分离的目的：将静态数据做缓存



缓存：

将静态数据放到离用户最近的地方：浏览器，cdn，服务端的cache

链接和数据做映射：

请求url：https://www.baidu.com获取一个数据，从中间的缓存key value中直接获取，url和页面做映射，如果再将value映射到客户端，连发送http请求都不需要了，不占用网络资源



请求的url页面和商品的id做关联，商品不需要查询数据库，而是查询静态服务器

https://item.jd.com/100037199931.html

秒杀系统：将商品作为静态数据，



![image-20230303090022602](%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96.assets/image-20230303090022602.png)



### 动静分离的实现方式

url唯一，做映射

特殊展示的元素做分离：尽可能的多做静态化

不同的用户的名称，头像等等不一样，但是整体页面都是一样的，比如我的订单，我的客服等等

将页面中的cookie，与用户个性化相关的数据去掉



### 架构方案

**静态服务器**：Nginx，Apache

**统一缓存管理服务器**：所有的静态数据，都请求这个服务器，由一个整体的服务来应对用户各种各样的缓存需求，额外在给你响应或者做缓存分发

详情页的缓存，图片的缓存，商品类目的缓存

**上CDN**



**问题**：如何在项目中应用

动态数据做静态的页面：

数据库中查询的数据 + css样式文件 = html文件

**问题**：比如Nginx和Tomcat在一个网络的两台服务器，做动静分离，静态数据一定是放在Nginx下还是放在，Nginx代理到Tomcat服务器的指定目录下？

最好是在Nginx下

**问题**：静态化数据，需要设置一定的过期时间，还是后端服务器变化了给消息推送通知

推荐使用后端服务器变化了给消息推送通知，实时性更高

静态化数据定时失效，有延迟展示

**问题**：浏览器和数据库一半存储哪些内容

需要在浏览器需要计算的一些中间数据可以存储



**以解决实际问题为主要目标**，不要拘泥于百分之百的完美

没有完美的方案，只能根据客户的要求和公司的现有成本的情况下，达到比较中和的方案
