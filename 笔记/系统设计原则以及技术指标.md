# 亿级流量多级缓存分布式（后端架构）



# 系统技术设计原则

## 设计原则一：好系统是迭代出来的

**面试问题：系统是怎么设计的？**

不要怕系统low，**好系统是迭代出来的**

先解决核心的问题，然后预测未来可能出现的问题



作为架构师，不要过度复杂化系统

先行的规划和设计：对现有的问题有方案，对未来系统有预案

## 设计原则二：无状态原则

无状态：对当前本次请求的处理，不依赖于其它的请求

处理一次请求所需要的全部信息，都在这个请求中，可以从外部进行获取（配置文件，数据库），服务器本身不存储任何信息



有状态：如果从服务器内部去获取，那就是有状态的

总结：如果服务器不保存请求状态的信息，那么就是无状态



**面试问题：所有的鉴权都是有状态的吗？**

正常情况下，用户需要先注册登录生成token，然后携带token进行其他业务的操作

但是当用户创建订单时需要token信息进行校验，而此时token信息是错误的或者为空，系统服务进行判断，转到登录状态，那么这也是无状态的



### 无状态的优点

服务器可以无限扩展，这就是水平扩展

举例：

用户注册进行登录生成token，如果使用服务器的session进行存储，那么每一台服务器都需要共享session，如果服务器不存储session，那么用户就无法进行登录，但是如果将token存储到Redis中，服务器就不需要共享session，那么服务器就可以无限扩展

总结：新部署的服务器不需要额外的操作，就能承载请求，这就是无状态



token：服务端的存储

1.不存token，缺点：不方便控制，token可以自过期（JWT）

2.存token，缺点：存储负担



## 设计原则三：拆分原则

巨石系统

用户量大了，业务复杂了，公司可以投入的资源多了

拆：高内聚，低耦合

**系统维度**：商品系统、购物车系统、支付系统、优惠券系统、订单系统

需要和产品经理配合，尽量将系统做成黑盒

**功能维度**：优惠券系统：后台创建优惠券的系统，用户领券系统，用券系统

**读写维度**：按照读写的比例进行拆分，读服务和写服务

读服务可以利用大量的缓存（多级缓存）

写服务可以利用分区分库分表

## 设计原则四：切面原则

cdn，类似于拦截器。对系统功能进行很详细的梳理，优化系统需要对系统特别的了解

## 设计原则五：模块原则

（基础模块）基础架构组：做一些很通用的支撑全公司的模块

（业务模块）二方库：不调用第三方，而是调用公司以内的模块

（代码维护特征模块）数据库连接模块，分库分表模块，综合消息队列模块（统一配置，主流消息队列）



## 设计原则六：服务化原则

单节点？节点集群？假设有1万个服务，如果服务之间需要互相调用，那么需要记住9999个ip地址，维护非常得麻烦

服务的治理：自动注册与发现

随着流量增大，流量不可控，需要进行限流、熔断、降级、隔离、恢复

服务之间调用报错，但是服务非常多，排查很困难，需要让服务自动去处理，这是服务化的原则



项目介绍，**一定要带上自己的思考**

代码中埋点



# 系统业务设计原则



## 设计原则一：防重原则，幂等原则

防止用户的重复操作

### 识别什么是重复

这是后端需要考虑的，因为模拟前端的接口的访问也能够绕过前端

读和写，读：不需要识别重复，写：有些不需要识别重复（逻辑删除，从1修改成0，再次删除也是从0到0，这个不需要识别重复）

### 针对重复做拒绝



## 设计原则二：模块复用原则

当你有拷贝欲望的时候，就需要考虑代码的重构了，沉淀通用功能





## 设计原则三：可追溯原则

任何问题，要有据可查，要好定位。

系统出现问题，查出错误很快

开发的时候，打印日志很重要，否则很麻烦



## 设计原则四：反馈原则

调用者访问接口，无论如何都要有一个详细明确的反馈





## 设计原则五：备份原则

### 代码备份

git：分支

### 数据备份

运维备份

操作记录（日志）备份

人员备份：也就是不因某个人的离职，而导致项目的停滞

**规范**：

1.代码都是统一风格

2.定期review

3.提交之前有责任人

如果review出错，罚款：写的人5000，往上审核的人10000，测试罚的更多

+1的软件：gerrit



# 软件质量衡量标准

从不同的维度对我所负责的项目进行评判

**面试、晋升、工作**中时使用的衡量标准

总结过去（衡量标准）：ios/iec 250xxxx

### 功能性

**功能性**：满足功能的需求

### 效能

**效能**：在指定的条件下，软件产品对资源占用的多少，投入多少，产出多少

投入的时间，投入的硬件资源，投入的容量：数据库大小，事务的吞吐量，网络带宽

产出多少：抗住了多少并发

### 兼容性

**兼容性**：产品系统或者组件，适用性更广

系统本身跑的好好地，是不是调用别的系统，软件就崩溃了，是不是调用第三方，崩溃了，或者接口没处理好，崩溃了，别人接入我的系统，崩溃了

### 易用性

**易用性**：在指定的环境中，能让用户很容易就达到要求

### 可靠性

**可靠性**：容错和可恢复

### 安全性

**安全性**：一上线用户输入个非法字符给崩溃了，用户量太大没有做限流也崩了

### 可维护性

**可维护性**：易读，项目的代码符合公司规范，同事可以很好的介入，不给公司埋坑

### 可移植性

**可移植性**：不同的平台运行都没有问题



写的越好，

我自己舒服，我的能力会变强，别人觉得我厉害



展望未来：



在别人的烂代码上做功能扩展怎么破？感觉烂又不敢动，太难了

解决方案：保证黑盒，由小到大（一行代码，一个方法，一个类，一个模块）



**表现自己的思考**



# 系统衡量标准



## 吞吐量

软件系统在单位时间内能够接收和发出的数据量

根据业务、服务器的配置



### TPS（transaction Per Second）每秒的事务数量，事务：请求、处理、响应

事务是一个不可分割的工作单元，不是数据库中的事务



### QPS（Queries Per Second）每秒的查询操作的数量



举例：

淘宝的页面就相当于一个事务T，每一次对后端的请求都是一个Q



### TPS和QPS的换算关系：

TPS和QPS的换算关系，必须由指定具体的业务场景来决定

场景在系统不同环境、不同时间、不同配置的机器上，TPS和QPS的变化



## 并发数

并发用户数：同时使用软件功能的人数

用户登录系统之后有没有进行操作

并发连接数：软件承载连接的数目

用户连接系统之后有没有进行操作

保持连接的开销非常小，几乎就没有

并发请求数：

大厂能抗住并发并不是程序员写代码，而是有钱，配置高

并发线程数：软件内部并行运行线程的数量

计算密集型的线程业务，在同等配置的情况下，线程数要调小



## 响应时间&平均响应时间RT（Response Time）

响应时间：针对某一个用户的请求时间



平均响应时间：将所有用户的请求时间做一个平均值





每个系统都有多个模块，每个模块都有自己的响应时间

提升系统的平均响应时间，通常是从提升模块的平均时间开始

### 阿姆达尔定理

#### 加速比：Rm = T旧/T新

对模块进行优化之后，模块带来的加速比

#### 增强比例：p = m模块的响应时间/总的响应时间

在优化之前，被优化的模块平均响应时间占系统平均响应时间的比



```
T新 = T旧 * [(1 - p) + p / Rm]
```



**增强比例p越大，新的模块响应时间越快**

所以第一反应就是优化最耗时的模块，IO：数据库

公式可以忽悠老板

**加速比Rm越大，新的模块响应时间越快**



## 可靠性指标

| 系统特性 | 第一个模块 | 第二个模块 | 第三个模块 | 第四个模块 | 第五个模块 | 结果 |
| :------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--: |
| 串联系统 |    99%     |    99%     |    99%     |    99%     |    99%     | 95%  |
| 并联系统 |   1 - r1   |   1 - r2   |   1 - r3   |   1 - r4   |   1 - r5   |      |

串联系统：99% * 99% * 99% * 99% * 99% = 95%，越乘以越小

冗余系统：

并联系统：1 - (1 - r1) * (1 - r2) * (1 - r3) * (1 - r4) * (1 - r5)，越乘以越大

所以推荐尽可能使用并联系统替换串联系统



## 消除单点

某种意义上来说，单点就是串行，就是转换串联为并联



用户本来是从缓存中请求数据，然后再请求数据库，这种方式是串联

将串联转换为并联之后，

用户直接请求缓存，如果缓存没有直接返回，并且缓存保证和数据库之间的数据同步，使用消息中间件发送消息异步更新缓存到数据库，这样系统更可靠

举例：

串联：你出去买东西，一手交钱一手交货

并联：你在网上买东西，先付钱，然后等一段时间之后会给你发货，这样就把交钱和交货分开了，能不能发货不影响你付款



用户 -> 缓存 -> 消息中间件 -> 数据库

read write through：调用方只和缓存打交道。是缓存保证和数据库的数据一致性

cache aside：如果缓存有，调用方就和缓存打交道，如果缓存没有，调用方就和数据库打交道



# 项目面试要点



如何学项目：

1.一定要熟悉需求，项目就是为了解决需求

2.解决方案，登录注册：校验，token的存储，防刷，黑名单，权限，颁发令牌，校验令牌，

3.难点，把你在学习某一个技术的时候，Redis搭建集群遇到的坑，数据量很大时发生不同步的解决方案，当多个用户共同的去抢某一个资源的时候，是怎么去控制的

重点：发现问题，找到原因（原理，源码），解决问题的过程

1.考验突出解决问题的能力，2.考验技术深度



问题：不好啊，作为一个大牛，怎么可以有难点





问题：项目的瓶颈是怎么优化的？









